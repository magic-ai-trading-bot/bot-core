name: Deploy to VPS

on:
  # Trigger after test-coverage workflow completes successfully
  workflow_run:
    workflows: ["Test Coverage & Quality Gates"]
    types:
      - completed
    branches: [main]

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if tests not run'
        required: false
        default: 'false'
        type: boolean

# Ensure only one deployment runs at a time
concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    # Only deploy if:
    # 1. Manual trigger with force_deploy, OR
    # 2. Workflow run completed successfully
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check deployment conditions
        id: check
        run: |
          echo "ğŸš€ Deployment triggered"
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Branch: ${{ github.event.workflow_run.head_branch }}"
          fi

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          echo "ğŸ” Connecting to VPS using password..."
          mkdir -p ~/.ssh
          ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Create deploy script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash

          # ============================================================================
          # SAFE DEPLOYMENT SCRIPT
          # ============================================================================
          # CRITICAL: This script is designed to NEVER delete data volumes
          # Only application containers are restarted, infrastructure stays running
          # ============================================================================

          # Don't use set -e globally - handle errors explicitly
          # set -e would exit on first error, leaving system in bad state

          DEPLOY_SUCCESS=true
          DEPLOY_DIR="/root/bot-core"
          DC="docker compose -f docker-compose-vps.yml"
          BACKUP_DIR="/root/backups"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)

          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m' # No Color

          log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
          log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
          log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

          # ============================================================================
          # STEP 1: PRE-DEPLOYMENT CHECKS
          # ============================================================================
          log_info "ğŸ” Step 1: Pre-deployment checks..."

          cd "$DEPLOY_DIR" || { log_error "Cannot cd to $DEPLOY_DIR"; exit 1; }

          # Create backup directory
          mkdir -p "$BACKUP_DIR"

          # Check critical volumes exist
          log_info "Checking data volumes..."
          MONGODB_VOLUME=$(docker volume ls -q | grep mongodb_data || true)
          REDIS_VOLUME=$(docker volume ls -q | grep redis_data || true)

          if [ -n "$MONGODB_VOLUME" ]; then
            log_info "âœ… MongoDB volume exists: $MONGODB_VOLUME"
          else
            log_warn "âš ï¸ MongoDB volume not found - first deployment?"
          fi

          if [ -n "$REDIS_VOLUME" ]; then
            log_info "âœ… Redis volume exists: $REDIS_VOLUME"
          else
            log_warn "âš ï¸ Redis volume not found"
          fi

          # ============================================================================
          # STEP 2: BACKUP SECRETS
          # ============================================================================
          log_info "ğŸ” Step 2: Backing up secrets..."

          if [ -f .env ]; then
            cp .env "$BACKUP_DIR/.env.backup.$TIMESTAMP"
            cp .env /tmp/.env.backup
            log_info "âœ… .env backed up"
          else
            log_warn "âš ï¸ No .env file found"
          fi

          # ============================================================================
          # STEP 3: BACKUP MONGODB DATA (Optional but recommended)
          # ============================================================================
          log_info "ğŸ’¾ Step 3: Creating MongoDB backup..."

          if docker ps | grep -q "mongodb.*healthy\|mongodb.*Up"; then
            # Quick dump of critical collections
            docker exec mongodb mongosh --eval "
              db = db.getSiblingDB('bot_core');
              print('Users: ' + db.users.countDocuments({}));
              print('Trades: ' + db.paper_trades.countDocuments({}));
              print('Portfolios: ' + db.paper_portfolios.countDocuments({}));
            " 2>/dev/null || log_warn "Could not get MongoDB stats"

            # Create backup (non-blocking, continues even if fails)
            docker exec mongodb mongodump --db=bot_core --out=/tmp/backup_$TIMESTAMP 2>/dev/null && \
              docker cp mongodb:/tmp/backup_$TIMESTAMP "$BACKUP_DIR/mongodb_backup_$TIMESTAMP" 2>/dev/null && \
              log_info "âœ… MongoDB backup created" || \
              log_warn "âš ï¸ MongoDB backup skipped (non-critical)"
          else
            log_warn "âš ï¸ MongoDB not running, skipping backup"
          fi

          # ============================================================================
          # STEP 4: PULL LATEST CODE
          # ============================================================================
          log_info "ğŸ“¦ Step 4: Pulling latest code..."

          git fetch origin main || { log_error "Git fetch failed"; exit 1; }
          git reset --hard origin/main || { log_error "Git reset failed"; exit 1; }
          log_info "âœ… Code updated to $(git rev-parse --short HEAD)"

          # ============================================================================
          # STEP 5: RESTORE SECRETS
          # ============================================================================
          log_info "ğŸ” Step 5: Restoring secrets..."

          if [ -f /tmp/.env.backup ]; then
            cp /tmp/.env.backup .env
            log_info "âœ… .env restored from backup"
          elif [ -f /root/bot-secrets.txt ]; then
            cp .env.example .env
            source /root/bot-secrets.txt
            sed -i "s|MONGO_ROOT_PASSWORD=.*|MONGO_ROOT_PASSWORD=$MONGO_ROOT_PASSWORD|g" .env
            sed -i "s|JWT_SECRET=.*|JWT_SECRET=$JWT_SECRET|g" .env
            log_info "âœ… .env created from bot-secrets.txt"
          else
            log_error "âŒ No .env backup found!"
            exit 1
          fi

          # Ensure all required env vars exist in .env (auto-generate if missing)
          REQUIRED_VARS="DASHBOARD_SESSION_SECRET INTER_SERVICE_TOKEN PYTHON_API_KEY RUST_API_KEY BINANCE_API_KEY BINANCE_SECRET_KEY"
          for var in $REQUIRED_VARS; do
            # Check if var exists and has a non-empty value
            CURRENT_VAL=$(grep "^${var}=" .env 2>/dev/null | head -1 | cut -d'=' -f2-)
            if [ -z "$CURRENT_VAL" ]; then
              # Remove empty entry if exists
              sed -i "/^${var}=$/d" .env 2>/dev/null || true
              GENERATED=$(openssl rand -hex 32)
              echo "${var}=$GENERATED" >> .env
              log_warn "âš ï¸ Generated missing/empty ${var}"
            fi
          done
          log_info "âœ… All required env vars verified"

          # ============================================================================
          # STEP 6: CLEANUP LEGACY CONTAINERS
          # ============================================================================
          log_info "ğŸ§¹ Step 6: Cleaning up legacy containers..."

          # Remove legacy enterprise containers (no longer used)
          LEGACY_CONTAINERS="grafana prometheus kong kong-database kong-migration rabbitmq celery-worker celery-beat flower"
          for container in $LEGACY_CONTAINERS; do
            if docker ps -a | grep -q "$container"; then
              docker stop "$container" 2>/dev/null || true
              docker rm -f "$container" 2>/dev/null || true
              log_info "Removed legacy: $container"
            fi
          done

          # Clean up old backups (keep only last 3)
          ls -t "$BACKUP_DIR"/mongodb_backup_* 2>/dev/null | tail -n +4 | xargs rm -rf 2>/dev/null || true
          ls -t "$BACKUP_DIR"/.env.backup.* 2>/dev/null | tail -n +4 | xargs rm -f 2>/dev/null || true

          log_info "ğŸ“Š Disk usage before build:"
          df -h / | tail -1

          # ============================================================================
          # âš ï¸ NEVER DELETE VOLUMES! âš ï¸
          # - docker volume prune / docker volume rm / docker compose down -v
          # ============================================================================

          # ============================================================================
          # STEP 7: DETECT CHANGED SERVICES (skip unchanged)
          # ============================================================================
          log_info "ğŸ” Step 7: Detecting changed services..."

          # Get the previous deployed commit (if any)
          PREV_SHA=$(cat /root/.bot-core-last-deploy-sha 2>/dev/null || echo "")
          CURR_SHA=$(git rev-parse HEAD)

          CHANGED_SERVICES=""
          if [ -z "$PREV_SHA" ] || [ "$PREV_SHA" = "$CURR_SHA" ]; then
            # First deploy or same commit - rebuild all
            CHANGED_SERVICES="all"
            log_info "Full rebuild (first deploy or forced)"
          else
            log_info "Comparing $PREV_SHA..$CURR_SHA"
            CHANGED_FILES=$(git diff --name-only "$PREV_SHA" "$CURR_SHA" 2>/dev/null || echo "all")

            if echo "$CHANGED_FILES" | grep -q "all\|docker-compose\|\.env\|Makefile"; then
              CHANGED_SERVICES="all"
              log_info "Infrastructure change detected - full rebuild"
            else
              if echo "$CHANGED_FILES" | grep -q "^rust-core-engine/"; then
                CHANGED_SERVICES="$CHANGED_SERVICES rust-core-engine"
              fi
              if echo "$CHANGED_FILES" | grep -q "^python-ai-service/"; then
                CHANGED_SERVICES="$CHANGED_SERVICES python-ai-service"
              fi
              if echo "$CHANGED_FILES" | grep -q "^nextjs-ui-dashboard/"; then
                CHANGED_SERVICES="$CHANGED_SERVICES nextjs-ui-dashboard"
              fi
              if echo "$CHANGED_FILES" | grep -q "^mcp-server/"; then
                CHANGED_SERVICES="$CHANGED_SERVICES mcp-server"
              fi
              if echo "$CHANGED_FILES" | grep -q "^openclaw/"; then
                CHANGED_SERVICES="$CHANGED_SERVICES openclaw"
              fi
            fi
          fi

          if [ -z "$CHANGED_SERVICES" ]; then
            log_info "âœ… No service changes detected - config-only update"
            CHANGED_SERVICES="none"
          fi
          log_info "Services to rebuild: $CHANGED_SERVICES"

          # ============================================================================
          # STEP 8: BUILD NEW IMAGES (while old containers keep running!)
          # ============================================================================
          log_info "ğŸ”¨ Step 8: Building images (old services stay running)..."

          # Copy root lockfile to frontend directory for Docker builds
          cp bun.lock nextjs-ui-dashboard/bun.lock 2>/dev/null || true

          build_service() {
            local svc=$1
            local required=${2:-true}
            log_info "Building $svc..."
            if $DC build "$svc"; then
              docker builder prune -f 2>/dev/null || true
              log_info "âœ… $svc built"
            elif [ "$required" = "true" ]; then
              log_error "$svc build failed!"
              exit 1
            else
              log_warn "$svc build failed (optional)"
            fi
          }

          if [ "$CHANGED_SERVICES" = "all" ]; then
            build_service nextjs-ui-dashboard true
            build_service python-ai-service true
            build_service rust-core-engine true
            build_service mcp-server false
            build_service openclaw false
          elif [ "$CHANGED_SERVICES" != "none" ]; then
            for svc in $CHANGED_SERVICES; do
              case "$svc" in
                mcp-server|openclaw) build_service "$svc" false ;;
                *) build_service "$svc" true ;;
              esac
            done
          fi

          log_info "âœ… Build complete"

          # ============================================================================
          # STEP 9: VERIFY INFRASTRUCTURE IS RUNNING
          # ============================================================================
          log_info "ğŸ” Step 9: Verifying infrastructure services..."

          # Ensure MongoDB is running
          if ! docker ps | grep -q "mongodb"; then
            log_warn "MongoDB not running, starting..."
            $DC up -d mongodb
            sleep 15
          fi

          # Verify MongoDB has data
          log_info "Checking MongoDB data..."
          docker exec mongodb mongosh --eval "
            db = db.getSiblingDB('bot_core');
            var users = db.users.countDocuments({});
            var trades = db.paper_trades.countDocuments({});
            print('Database check - Users: ' + users + ', Trades: ' + trades);
            if (users == 0) {
              print('WARNING: No users found in database!');
            }
          " 2>/dev/null || log_warn "Could not verify MongoDB data"

          # Ensure Redis is running
          if ! docker ps | grep -q "redis-cache"; then
            log_warn "Redis not running, starting..."
            $DC up -d redis
            sleep 5
          fi

          # ============================================================================
          # STEP 10: ROLLING RESTART (one service at a time, zero downtime)
          # ============================================================================
          log_info "ğŸš€ Step 10: Rolling restart (zero-downtime)..."

          # docker compose up -d only recreates containers whose image changed
          # Old containers keep serving until new ones are healthy
          $DC up -d rust-core-engine python-ai-service nextjs-ui-dashboard
          sleep 10

          # MCP Server
          if ! $DC up -d mcp-server 2>&1; then
            log_warn "MCP Server start failed"
            docker logs mcp-server --tail 30 2>&1 || true
          fi
          sleep 10

          # OpenClaw
          if ! $DC up -d openclaw 2>&1; then
            log_warn "OpenClaw start failed"
            docker logs openclaw --tail 30 2>&1 || true
          fi

          # Save deployed commit SHA for next diff
          echo "$CURR_SHA" > /root/.bot-core-last-deploy-sha

          # Clean up old images after successful restart
          docker image prune -f 2>/dev/null || true

          # ============================================================================
          # STEP 12: HEALTH CHECKS
          # ============================================================================
          log_info "â³ Step 12: Running health checks..."
          sleep 30

          check_service() {
            local name=$1
            local url=$2
            local max_attempts=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if curl -sf "$url" > /dev/null 2>&1; then
                log_info "âœ… $name healthy"
                return 0
              fi
              echo "â³ $name not ready, attempt $attempt/$max_attempts..."
              sleep 5
              attempt=$((attempt + 1))
            done

            log_error "âŒ $name unhealthy after $max_attempts attempts"
            return 1
          }

          # Core services health check
          check_service "Rust API" "http://localhost:8080/api/health" || DEPLOY_SUCCESS=false
          check_service "Python AI" "http://localhost:8000/health" || DEPLOY_SUCCESS=false
          check_service "Frontend" "http://localhost:3000" || DEPLOY_SUCCESS=false

          # Optional services health check (don't fail deploy if these are down)
          if ! check_service "MCP Server" "http://localhost:8090/health"; then
            log_warn "MCP Server not healthy - showing logs:"
            docker logs mcp-server --tail 20 2>&1 || true
          fi
          # OpenClaw has no HTTP health endpoint - check Docker health status
          OPENCLAW_OK=false
          for i in $(seq 1 10); do
            HEALTH=$(docker inspect --format='{{.State.Health.Status}}' openclaw 2>/dev/null || echo "missing")
            if [ "$HEALTH" = "healthy" ]; then
              log_info "âœ… OpenClaw healthy"
              OPENCLAW_OK=true
              break
            fi
            echo "â³ OpenClaw health: $HEALTH, attempt $i/10..."
            sleep 10
          done
          if [ "$OPENCLAW_OK" = "false" ]; then
            log_warn "OpenClaw not healthy - showing logs:"
            docker logs openclaw --tail 20 2>&1 || true
          fi

          # ============================================================================
          # STEP 13: FINAL STATUS
          # ============================================================================
          echo ""
          log_info "ğŸ“‹ All running services:"
          $DC ps --format "table {{.Names}}\t{{.Status}}" 2>/dev/null | grep -v "Created\|Exited" || docker ps --format "table {{.Names}}\t{{.Status}}"

          echo ""
          log_info "ğŸ“Š Final disk usage:"
          df -h /

          # ============================================================================
          # STEP 14: SEND TELEGRAM NOTIFICATION
          # ============================================================================
          log_info "ğŸ“± Step 14: Sending Telegram notification..."

          TELEGRAM_BOT_TOKEN=$(grep '^TELEGRAM_BOT_TOKEN=' .env | cut -d= -f2-)
          TELEGRAM_USER_ID=$(grep '^TELEGRAM_USER_ID=' .env | cut -d= -f2-)
          SHORT_SHA=$(echo "$CURR_SHA" | cut -c1-7)
          COMMIT_MSG=$(git log -1 --pretty=format:"%s" 2>/dev/null || echo "unknown")

          if [ -n "$TELEGRAM_BOT_TOKEN" ] && [ -n "$TELEGRAM_USER_ID" ]; then
            VPS_IP=$(curl -s ifconfig.me 2>/dev/null || echo "VPS")
            if [ "$DEPLOY_SUCCESS" = true ]; then
              printf -v NOTIF_TEXT "ğŸš€ <b>Deploy thÃ nh cÃ´ng!</b>\n\nğŸ“¦ <code>%s</code> â€” %s\nğŸ”„ Services: %s\n\nâœ… All services healthy\nğŸ“Š Dashboard: http://%s:3000" "$SHORT_SHA" "$COMMIT_MSG" "$CHANGED_SERVICES" "$VPS_IP"
            else
              printf -v NOTIF_TEXT "âš ï¸ <b>Deploy hoÃ n táº¥t vá»›i lá»—i</b>\n\nğŸ“¦ <code>%s</code> â€” %s\nğŸ”„ Services: %s\n\nKiá»ƒm tra: <code>docker logs [service] --tail 50</code>" "$SHORT_SHA" "$COMMIT_MSG" "$CHANGED_SERVICES"
            fi
            curl -s "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
              -d "chat_id=${TELEGRAM_USER_ID}" \
              -d "parse_mode=HTML" \
              --data-urlencode "text=${NOTIF_TEXT}" > /dev/null 2>&1 && \
              log_info "âœ… Telegram notification sent" || \
              log_warn "âš ï¸ Telegram notification failed (non-critical)"
          else
            log_warn "âš ï¸ TELEGRAM_BOT_TOKEN or TELEGRAM_USER_ID not set, skipping notification"
          fi

          echo ""
          if [ "$DEPLOY_SUCCESS" = true ]; then
            log_info "ğŸ‰ Deployment successful!"
            echo "ğŸ“Š Dashboard: http://$(curl -s ifconfig.me 2>/dev/null || echo 'YOUR_IP'):3000"
            exit 0
          else
            log_error "âŒ Deployment completed with errors - check logs above"
            exit 1
          fi
          DEPLOY_SCRIPT

          # Execute deploy script on VPS using password authentication
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=30 -o ServerAliveCountMax=60 "$VPS_USER@$VPS_HOST" 'bash -s' < deploy.sh

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "âœ… Deployment to production successful!"
          else
            echo "âŒ Deployment failed!"
          fi

      - name: Create deployment summary
        if: success()
        run: |
          echo "## ğŸš€ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Core Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Dashboard | http://${{ secrets.VPS_HOST }}:3000 | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| Rust API | http://${{ secrets.VPS_HOST }}:8080 | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "| Python AI | http://${{ secrets.VPS_HOST }}:8000 | âœ… |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### AI Assistant Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Port | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| MCP Server | 8090 | BotCore API Bridge |" >> $GITHUB_STEP_SUMMARY
          echo "| OpenClaw | 18789 | AI Trading Assistant |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Infrastructure" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Port | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| MongoDB | 27017 | Primary Database |" >> $GITHUB_STEP_SUMMARY
          echo "| Redis | 6379 | Cache |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.event.workflow_run.head_sha || github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** main" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY
