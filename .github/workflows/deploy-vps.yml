name: Deploy to VPS

on:
  # Trigger after test-coverage workflow completes successfully
  workflow_run:
    workflows: ["Test Coverage & Quality Gates"]
    types:
      - completed
    branches: [main]

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if tests not run'
        required: false
        default: 'false'
        type: boolean

# Ensure only one deployment runs at a time
concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    # Only deploy if:
    # 1. Manual trigger with force_deploy, OR
    # 2. Workflow run completed successfully
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')

    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Check deployment conditions
        id: check
        run: |
          echo "üöÄ Deployment triggered"
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Branch: ${{ github.event.workflow_run.head_branch }}"
          fi

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          echo "üîê Connecting to VPS using password..."
          mkdir -p ~/.ssh
          ssh-keyscan -H "$VPS_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

          # Create deploy script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash

          # ============================================================================
          # SAFE DEPLOYMENT SCRIPT
          # ============================================================================
          # CRITICAL: This script is designed to NEVER delete data volumes
          # Only application containers are restarted, infrastructure stays running
          # ============================================================================

          # Don't use set -e globally - handle errors explicitly
          # set -e would exit on first error, leaving system in bad state

          DEPLOY_SUCCESS=true
          DEPLOY_DIR="/root/bot-core"
          BACKUP_DIR="/root/backups"
          TIMESTAMP=$(date +%Y%m%d_%H%M%S)

          # Colors for output
          RED='\033[0;31m'
          GREEN='\033[0;32m'
          YELLOW='\033[1;33m'
          NC='\033[0m' # No Color

          log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
          log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
          log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

          # ============================================================================
          # STEP 1: PRE-DEPLOYMENT CHECKS
          # ============================================================================
          log_info "üîç Step 1: Pre-deployment checks..."

          cd "$DEPLOY_DIR" || { log_error "Cannot cd to $DEPLOY_DIR"; exit 1; }

          # Create backup directory
          mkdir -p "$BACKUP_DIR"

          # Check critical volumes exist
          log_info "Checking data volumes..."
          MONGODB_VOLUME=$(docker volume ls -q | grep mongodb_data || true)
          REDIS_VOLUME=$(docker volume ls -q | grep redis_data || true)

          if [ -n "$MONGODB_VOLUME" ]; then
            log_info "‚úÖ MongoDB volume exists: $MONGODB_VOLUME"
          else
            log_warn "‚ö†Ô∏è MongoDB volume not found - first deployment?"
          fi

          if [ -n "$REDIS_VOLUME" ]; then
            log_info "‚úÖ Redis volume exists: $REDIS_VOLUME"
          else
            log_warn "‚ö†Ô∏è Redis volume not found"
          fi

          # ============================================================================
          # STEP 2: BACKUP SECRETS
          # ============================================================================
          log_info "üîê Step 2: Backing up secrets..."

          if [ -f .env ]; then
            cp .env "$BACKUP_DIR/.env.backup.$TIMESTAMP"
            cp .env /tmp/.env.backup
            log_info "‚úÖ .env backed up"
          else
            log_warn "‚ö†Ô∏è No .env file found"
          fi

          # ============================================================================
          # STEP 3: BACKUP MONGODB DATA (Optional but recommended)
          # ============================================================================
          log_info "üíæ Step 3: Creating MongoDB backup..."

          if docker ps | grep -q "mongodb.*healthy\|mongodb.*Up"; then
            # Quick dump of critical collections
            docker exec mongodb mongosh --eval "
              db = db.getSiblingDB('bot_core');
              print('Users: ' + db.users.countDocuments({}));
              print('Trades: ' + db.paper_trades.countDocuments({}));
              print('Portfolios: ' + db.paper_portfolios.countDocuments({}));
            " 2>/dev/null || log_warn "Could not get MongoDB stats"

            # Create backup (non-blocking, continues even if fails)
            docker exec mongodb mongodump --db=bot_core --out=/tmp/backup_$TIMESTAMP 2>/dev/null && \
              docker cp mongodb:/tmp/backup_$TIMESTAMP "$BACKUP_DIR/mongodb_backup_$TIMESTAMP" 2>/dev/null && \
              log_info "‚úÖ MongoDB backup created" || \
              log_warn "‚ö†Ô∏è MongoDB backup skipped (non-critical)"
          else
            log_warn "‚ö†Ô∏è MongoDB not running, skipping backup"
          fi

          # ============================================================================
          # STEP 4: PULL LATEST CODE
          # ============================================================================
          log_info "üì¶ Step 4: Pulling latest code..."

          git fetch origin main || { log_error "Git fetch failed"; exit 1; }
          git reset --hard origin/main || { log_error "Git reset failed"; exit 1; }
          log_info "‚úÖ Code updated to $(git rev-parse --short HEAD)"

          # ============================================================================
          # STEP 5: RESTORE SECRETS
          # ============================================================================
          log_info "üîê Step 5: Restoring secrets..."

          if [ -f /tmp/.env.backup ]; then
            cp /tmp/.env.backup .env
            log_info "‚úÖ .env restored from backup"
          elif [ -f /root/bot-secrets.txt ]; then
            cp .env.example .env
            source /root/bot-secrets.txt
            sed -i "s|MONGO_ROOT_PASSWORD=.*|MONGO_ROOT_PASSWORD=$MONGO_ROOT_PASSWORD|g" .env
            sed -i "s|JWT_SECRET=.*|JWT_SECRET=$JWT_SECRET|g" .env
            log_info "‚úÖ .env created from bot-secrets.txt"
          else
            log_error "‚ùå No .env backup found!"
            exit 1
          fi

          # ============================================================================
          # STEP 6: STOP ONLY APPLICATION CONTAINERS (KEEP INFRASTRUCTURE RUNNING!)
          # ============================================================================
          log_info "üõë Step 6: Stopping application containers ONLY..."
          log_warn "‚ö†Ô∏è IMPORTANT: MongoDB and Redis will NOT be stopped to preserve data"

          # List of app containers to restart (NOT infrastructure)
          APP_CONTAINERS="rust-core-engine python-ai-service nextjs-ui-dashboard"

          for container in $APP_CONTAINERS; do
            if docker ps -a | grep -q "$container"; then
              docker stop "$container" 2>/dev/null || true
              docker rm -f "$container" 2>/dev/null || true
              log_info "Stopped: $container"
            fi
          done

          # Also handle celery containers (can be restarted safely)
          CELERY_CONTAINERS="celery-worker celery-beat flower"
          for container in $CELERY_CONTAINERS; do
            if docker ps -a | grep -q "$container"; then
              docker stop "$container" 2>/dev/null || true
              docker rm -f "$container" 2>/dev/null || true
              log_info "Stopped: $container"
            fi
          done

          # ============================================================================
          # STEP 7: CLEANUP (SAFE - NO VOLUME DELETION!)
          # ============================================================================
          log_info "üßπ Step 7: Safe cleanup..."

          # Remove stopped containers (safe)
          docker container prune -f 2>/dev/null || true

          # Remove dangling images only (safe)
          docker image prune -f 2>/dev/null || true

          # Remove build cache (safe)
          docker builder prune -f 2>/dev/null || true

          # ============================================================================
          # ‚ö†Ô∏è NEVER DELETE VOLUMES! ‚ö†Ô∏è
          # The following commands are DANGEROUS and should NEVER be run:
          # - docker volume prune
          # - docker volume rm
          # - docker system prune -a --volumes
          # - docker compose down -v
          # ============================================================================

          log_info "üìä Disk usage after cleanup:"
          df -h / | tail -1

          # ============================================================================
          # STEP 8: BUILD NEW IMAGES
          # ============================================================================
          log_info "üî® Step 8: Building application images..."

          docker compose build rust-core-engine nextjs-ui-dashboard python-ai-service || {
            log_error "Build failed!"
            exit 1
          }
          log_info "‚úÖ Images built successfully"

          # ============================================================================
          # STEP 9: VERIFY INFRASTRUCTURE IS RUNNING
          # ============================================================================
          log_info "üîç Step 9: Verifying infrastructure services..."

          # Ensure MongoDB is running (should already be running)
          if ! docker ps | grep -q "mongodb"; then
            log_warn "MongoDB not running, starting..."
            docker compose up -d mongodb
            sleep 15
          fi

          # Verify MongoDB has data
          log_info "Checking MongoDB data..."
          docker exec mongodb mongosh --eval "
            db = db.getSiblingDB('bot_core');
            var users = db.users.countDocuments({});
            var trades = db.paper_trades.countDocuments({});
            print('Database check - Users: ' + users + ', Trades: ' + trades);
            if (users == 0) {
              print('WARNING: No users found in database!');
            }
          " 2>/dev/null || log_warn "Could not verify MongoDB data"

          # Ensure Redis is running
          if ! docker ps | grep -q "redis-cache"; then
            log_warn "Redis not running, starting..."
            docker compose --profile redis up -d redis
            sleep 5
          fi

          # ============================================================================
          # STEP 10: START APPLICATION SERVICES
          # ============================================================================
          log_info "üöÄ Step 10: Starting application services..."

          docker compose --profile prod up -d rust-core-engine python-ai-service nextjs-ui-dashboard
          sleep 30

          # ============================================================================
          # STEP 11: START MESSAGING SERVICES
          # ============================================================================
          log_info "üì® Step 11: Starting messaging services..."

          # RabbitMQ
          if ! docker ps | grep -q "rabbitmq"; then
            docker compose --profile messaging up -d rabbitmq
            sleep 20
          fi

          # Wait for RabbitMQ to be ready
          for i in {1..5}; do
            if docker exec rabbitmq rabbitmqctl list_vhosts 2>/dev/null | grep -q "bot-core"; then
              log_info "‚úÖ RabbitMQ ready"
              break
            fi
            log_info "Waiting for RabbitMQ... ($i/5)"
            sleep 5
          done

          # Celery services
          docker compose --profile messaging up -d celery-worker celery-beat flower 2>/dev/null || true

          # ============================================================================
          # STEP 12: START MONITORING (Optional)
          # ============================================================================
          log_info "üìä Step 12: Starting monitoring services..."
          docker compose --profile monitoring --profile api-gateway up -d 2>/dev/null || true

          # ============================================================================
          # STEP 13: HEALTH CHECKS
          # ============================================================================
          log_info "‚è≥ Step 13: Running health checks..."
          sleep 30

          check_service() {
            local name=$1
            local url=$2
            local max_attempts=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if curl -sf "$url" > /dev/null 2>&1; then
                log_info "‚úÖ $name healthy"
                return 0
              fi
              echo "‚è≥ $name not ready, attempt $attempt/$max_attempts..."
              sleep 5
              attempt=$((attempt + 1))
            done

            log_error "‚ùå $name unhealthy after $max_attempts attempts"
            return 1
          }

          # Core services health check
          check_service "Rust API" "http://localhost:8080/api/health" || DEPLOY_SUCCESS=false
          check_service "Python AI" "http://localhost:8000/health" || DEPLOY_SUCCESS=false
          check_service "Frontend" "http://localhost:3000" || DEPLOY_SUCCESS=false

          # ============================================================================
          # STEP 14: FINAL STATUS
          # ============================================================================
          echo ""
          log_info "üìã All running services:"
          docker compose ps --format "table {{.Names}}\t{{.Status}}" 2>/dev/null | grep -v "Created\|Exited" || docker ps --format "table {{.Names}}\t{{.Status}}"

          echo ""
          log_info "üìä Final disk usage:"
          df -h /

          echo ""
          if [ "$DEPLOY_SUCCESS" = true ]; then
            log_info "üéâ Deployment successful!"
            echo "üìä Dashboard: http://$(curl -s ifconfig.me 2>/dev/null || echo 'YOUR_IP'):3000"
            exit 0
          else
            log_error "‚ùå Deployment completed with errors - check logs above"
            exit 1
          fi
          DEPLOY_SCRIPT

          # Execute deploy script on VPS using password authentication
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no "$VPS_USER@$VPS_HOST" 'bash -s' < deploy.sh

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to production successful!"
          else
            echo "‚ùå Deployment failed!"
          fi

      - name: Create deployment summary
        if: success()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Core Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Dashboard | http://${{ secrets.VPS_HOST }}:3000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Rust API | http://${{ secrets.VPS_HOST }}:8080 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Python AI | http://${{ secrets.VPS_HOST }}:8000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Enterprise Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Port | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| RabbitMQ | 15672 | Message Queue |" >> $GITHUB_STEP_SUMMARY
          echo "| Flower | 5555 | Celery Monitor |" >> $GITHUB_STEP_SUMMARY
          echo "| Grafana | 3001 | Monitoring |" >> $GITHUB_STEP_SUMMARY
          echo "| Prometheus | 9090 | Metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| Kong | 8100 | API Gateway |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** main" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY
