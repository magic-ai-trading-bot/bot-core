name: Deploy to VPS

on:
  # Trigger after test-coverage workflow completes successfully
  workflow_run:
    workflows: ["Test Coverage & Quality Gates"]
    types:
      - completed
    branches: [main]

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if tests not run'
        required: false
        default: 'false'
        type: boolean

# Ensure only one deployment runs at a time
concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    # Only deploy if:
    # 1. Manual trigger with force_deploy, OR
    # 2. Workflow run completed successfully
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check deployment conditions
        id: check
        run: |
          echo "üöÄ Deployment triggered"
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Branch: ${{ github.event.workflow_run.head_branch }}"
          fi

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          echo "üîê Connecting to VPS..."

          # Create deploy script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          echo "üì¶ Pulling latest code..."
          cd /root/bot-core
          git fetch origin main
          git reset --hard origin/main

          echo "üßπ Docker cleanup (preserving data volumes)..."
          # Stop containers gracefully (without removing volumes)
          docker compose down --remove-orphans || true

          # Remove stopped containers and dangling images only
          docker container prune -f || true
          docker image prune -f || true

          # Remove dangling volumes only (keeps named volumes like mongodb_data)
          docker volume ls -qf dangling=true | xargs -r docker volume rm || true

          # Remove build cache
          docker builder prune -f || true

          # Show disk usage after cleanup
          echo "üìä Disk usage after cleanup:"
          df -h /
          docker system df

          echo "üî® Building services..."
          docker compose build rust-core-engine nextjs-ui-dashboard python-ai-service

          echo "üîÑ Starting ALL services (including enterprise features)..."
          # Start mongodb first (no profile required)
          docker compose up -d mongodb

          # Wait for mongodb to be healthy
          echo "‚è≥ Waiting for MongoDB to be healthy..."
          sleep 10

          # Start all profiled services: prod + redis + messaging + monitoring + api-gateway
          # This includes redis service which requires --profile redis or --profile messaging
          docker compose --profile prod --profile redis --profile messaging --profile monitoring --profile api-gateway up -d

          echo "‚è≥ Waiting for services to be healthy..."
          sleep 30

          echo "‚úÖ Checking service health..."
          docker ps --format "table {{.Names}}\t{{.Status}}"

          # Core services health check
          if curl -sf http://localhost:8080/api/health > /dev/null; then
            echo "‚úÖ Rust API healthy"
          else
            echo "‚ùå Rust API unhealthy"
            exit 1
          fi

          if curl -sf http://localhost:8000/health > /dev/null; then
            echo "‚úÖ Python AI healthy"
          else
            echo "‚ùå Python AI unhealthy"
            exit 1
          fi

          if curl -sf http://localhost:3000 > /dev/null; then
            echo "‚úÖ Frontend healthy"
          else
            echo "‚ùå Frontend unhealthy"
            exit 1
          fi

          # Enterprise services health check
          if docker ps | grep -q "celery-worker.*healthy"; then
            echo "‚úÖ Celery Worker healthy"
          else
            echo "‚ö†Ô∏è Celery Worker not healthy (non-critical)"
          fi

          if docker ps | grep -q "celery-beat.*healthy"; then
            echo "‚úÖ Celery Beat healthy"
          else
            echo "‚ö†Ô∏è Celery Beat not healthy (non-critical)"
          fi

          if docker ps | grep -q "rabbitmq.*healthy"; then
            echo "‚úÖ RabbitMQ healthy"
          else
            echo "‚ö†Ô∏è RabbitMQ not healthy (non-critical)"
          fi

          # Show all running services
          echo ""
          echo "üìã All running services:"
          docker compose ps --format "table {{.Names}}\t{{.Status}}" | grep -v "Created\|Exited"

          # Cleanup dangling images only (not all unused)
          echo "üßπ Final cleanup..."
          docker image prune -f || true

          echo ""
          echo "üìä Final disk usage:"
          df -h /

          echo ""
          echo "üéâ Deployment successful!"
          echo "üìä Dashboard: http://$(curl -s ifconfig.me):3000"
          DEPLOY_SCRIPT

          # Execute deploy script on VPS
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no "$VPS_USER@$VPS_HOST" 'bash -s' < deploy.sh

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to production successful!"
          else
            echo "‚ùå Deployment failed!"
          fi

      - name: Create deployment summary
        if: success()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Core Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Dashboard | http://${{ secrets.VPS_HOST }}:3000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Rust API | http://${{ secrets.VPS_HOST }}:8080 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Python AI | http://${{ secrets.VPS_HOST }}:8000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Enterprise Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Port | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| RabbitMQ | 15672 | Message Queue |" >> $GITHUB_STEP_SUMMARY
          echo "| Flower | 5555 | Celery Monitor |" >> $GITHUB_STEP_SUMMARY
          echo "| Grafana | 3001 | Monitoring |" >> $GITHUB_STEP_SUMMARY
          echo "| Prometheus | 9090 | Metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| Kong | 8100 | API Gateway |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** main" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY
