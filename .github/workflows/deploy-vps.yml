name: Deploy to VPS

on:
  # Trigger after test-coverage workflow completes successfully
  workflow_run:
    workflows: ["Test Coverage & Quality Gates"]
    types:
      - completed
    branches: [main]

  # Allow manual trigger
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deploy even if tests not run'
        required: false
        default: 'false'
        type: boolean

# Ensure only one deployment runs at a time
concurrency:
  group: deploy-production
  cancel-in-progress: false

jobs:
  deploy:
    name: Deploy to Production VPS
    runs-on: ubuntu-latest
    # Only deploy if:
    # 1. Manual trigger with force_deploy, OR
    # 2. Workflow run completed successfully
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Check deployment conditions
        id: check
        run: |
          echo "üöÄ Deployment triggered"
          echo "Event: ${{ github.event_name }}"
          if [ "${{ github.event_name }}" == "workflow_run" ]; then
            echo "Workflow: ${{ github.event.workflow_run.name }}"
            echo "Conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Branch: ${{ github.event.workflow_run.head_branch }}"
          fi

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_PASSWORD: ${{ secrets.VPS_PASSWORD }}
        run: |
          echo "üîê Connecting to VPS..."

          # Create deploy script
          cat > deploy.sh << 'DEPLOY_SCRIPT'
          #!/bin/bash
          set -e

          echo "üì¶ Pulling latest code..."
          cd /root/bot-core

          # Backup .env file before git reset (preserves secrets like JWT_SECRET)
          echo "üîê Backing up secrets..."
          if [ -f .env ]; then
            cp .env /tmp/.env.backup
            echo "  ‚úì .env backed up"
          fi

          git fetch origin main
          git reset --hard origin/main

          # Restore .env file after git reset (preserves JWT_SECRET for user sessions)
          echo "üîê Restoring secrets..."
          if [ -f /tmp/.env.backup ]; then
            cp /tmp/.env.backup .env
            echo "  ‚úì .env restored from backup"
          elif [ -f /root/bot-secrets.txt ]; then
            # Fallback: source from bot-secrets.txt created during initial setup
            cp .env.example .env
            source /root/bot-secrets.txt
            sed -i "s|MONGO_ROOT_PASSWORD=.*|MONGO_ROOT_PASSWORD=$MONGO_ROOT_PASSWORD|g" .env
            sed -i "s|JWT_SECRET=.*|JWT_SECRET=$JWT_SECRET|g" .env
            echo "  ‚úì .env created from bot-secrets.txt"
          else
            echo "  ‚ö†Ô∏è Warning: No .env backup found, using defaults"
          fi

          echo "üßπ Docker cleanup (preserving data volumes)..."
          # Stop containers gracefully (without removing volumes)
          docker compose down --remove-orphans || true

          # Remove stopped containers and dangling images only
          docker container prune -f || true
          docker image prune -f || true

          # Remove dangling volumes only (keeps named volumes like mongodb_data)
          docker volume ls -qf dangling=true | xargs -r docker volume rm || true

          # Remove build cache
          docker builder prune -f || true

          # Show disk usage after cleanup
          echo "üìä Disk usage after cleanup:"
          df -h /
          docker system df

          echo "üî® Building services..."
          docker compose build rust-core-engine nextjs-ui-dashboard python-ai-service

          echo "üîÑ Starting services in correct order..."

          # Step 1: Start infrastructure services (mongodb, redis)
          echo "üì¶ Step 1: Starting infrastructure services..."
          docker compose up -d mongodb
          docker compose --profile redis up -d redis
          sleep 15

          # Step 2: Start core application services
          echo "üöÄ Step 2: Starting core services..."
          docker compose --profile prod up -d rust-core-engine python-ai-service nextjs-ui-dashboard
          sleep 30

          # Step 3: Start messaging services (RabbitMQ first, then Celery)
          echo "üì® Step 3: Starting messaging services..."
          docker compose --profile messaging up -d rabbitmq
          sleep 20

          # Ensure RabbitMQ has proper setup (user/vhost)
          echo "üîß Initializing RabbitMQ..."
          for i in {1..5}; do
            if docker exec rabbitmq rabbitmqctl list_vhosts 2>/dev/null | grep -q "bot-core"; then
              echo "‚úÖ RabbitMQ vhost exists"
              break
            fi
            echo "‚è≥ Waiting for RabbitMQ initialization (attempt $i/5)..."
            sleep 5
          done

          # Start Celery services (non-blocking)
          echo "üîÑ Starting Celery services..."
          docker compose --profile messaging up -d celery-worker celery-beat flower || true

          # Step 4: Start monitoring and gateway
          echo "üìä Step 4: Starting monitoring and gateway..."
          docker compose --profile monitoring --profile api-gateway up -d || true

          echo "‚è≥ Waiting for services to be healthy..."
          sleep 45

          echo "‚úÖ Checking service health with retries..."
          docker ps --format "table {{.Names}}\t{{.Status}}"

          # Function to check service with retries
          check_service() {
            local name=$1
            local url=$2
            local max_attempts=10
            local attempt=1

            while [ $attempt -le $max_attempts ]; do
              if curl -sf "$url" > /dev/null 2>&1; then
                echo "‚úÖ $name healthy"
                return 0
              fi
              echo "‚è≥ $name not ready, attempt $attempt/$max_attempts..."
              sleep 5
              attempt=$((attempt + 1))
            done

            echo "‚ùå $name unhealthy after $max_attempts attempts"
            return 1
          }

          # Core services health check with retries
          check_service "Rust API" "http://localhost:8080/api/health" || exit 1
          check_service "Python AI" "http://localhost:8000/health" || exit 1
          check_service "Frontend" "http://localhost:3000" || exit 1

          # Enterprise services health check
          if docker ps | grep -q "celery-worker.*healthy"; then
            echo "‚úÖ Celery Worker healthy"
          else
            echo "‚ö†Ô∏è Celery Worker not healthy (non-critical)"
          fi

          if docker ps | grep -q "celery-beat.*healthy"; then
            echo "‚úÖ Celery Beat healthy"
          else
            echo "‚ö†Ô∏è Celery Beat not healthy (non-critical)"
          fi

          if docker ps | grep -q "rabbitmq.*healthy"; then
            echo "‚úÖ RabbitMQ healthy"
          else
            echo "‚ö†Ô∏è RabbitMQ not healthy (non-critical)"
          fi

          # Show all running services
          echo ""
          echo "üìã All running services:"
          docker compose ps --format "table {{.Names}}\t{{.Status}}" | grep -v "Created\|Exited"

          # Cleanup dangling images only (not all unused)
          echo "üßπ Final cleanup..."
          docker image prune -f || true

          echo ""
          echo "üìä Final disk usage:"
          df -h /

          echo ""
          echo "üéâ Deployment successful!"
          echo "üìä Dashboard: http://$(curl -s ifconfig.me):3000"
          DEPLOY_SCRIPT

          # Execute deploy script on VPS
          sshpass -p "$VPS_PASSWORD" ssh -o StrictHostKeyChecking=no "$VPS_USER@$VPS_HOST" 'bash -s' < deploy.sh

      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment to production successful!"
          else
            echo "‚ùå Deployment failed!"
          fi

      - name: Create deployment summary
        if: success()
        run: |
          echo "## üöÄ Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Core Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | URL | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-----|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Dashboard | http://${{ secrets.VPS_HOST }}:3000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Rust API | http://${{ secrets.VPS_HOST }}:8080 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "| Python AI | http://${{ secrets.VPS_HOST }}:8000 | ‚úÖ |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Enterprise Services" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Port | Description |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|------|-------------|" >> $GITHUB_STEP_SUMMARY
          echo "| RabbitMQ | 15672 | Message Queue |" >> $GITHUB_STEP_SUMMARY
          echo "| Flower | 5555 | Celery Monitor |" >> $GITHUB_STEP_SUMMARY
          echo "| Grafana | 3001 | Monitoring |" >> $GITHUB_STEP_SUMMARY
          echo "| Prometheus | 9090 | Metrics |" >> $GITHUB_STEP_SUMMARY
          echo "| Kong | 8100 | API Gateway |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** main" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u)" >> $GITHUB_STEP_SUMMARY
